{
  "version": 3,
  "sources": ["HotZoneManager.ts"],
  "sourcesContent": ["import { injectable } from \"tsyringe\";\r\nimport { ConfigManager } from \"./ConfigManager\";\r\n\r\nexport interface IHotZone {\r\n    enabled: boolean;\r\n    description: string;\r\n    spawnTypes: string[];\r\n    maxBots: number;\r\n    spawnChance: number;\r\n    spawnTiming: string;\r\n    priority: string;\r\n    coordinates: {\r\n        x: number;\r\n        y: number;\r\n        radius: number;\r\n    };\r\n    questRelated: boolean;\r\n    questName?: string;\r\n}\r\n\r\nexport interface IHotZoneConfig {\r\n    enabled: boolean;\r\n    hotZones: Record<string, Record<string, IHotZone>>;\r\n    spawnDistribution: {\r\n        enabled: boolean;\r\n        minDistanceBetweenSpawns: number;\r\n        maxSpawnsPerZone: number;\r\n        zonePriority: Record<string, number>;\r\n        spawnTiming: {\r\n            initialSpawnDelay: number;\r\n            waveSpacing: number;\r\n            randomization: number;\r\n        };\r\n    };\r\n    integration: {\r\n        waypointsMod: boolean;\r\n        bigBrainMod: boolean;\r\n        useExistingPathfinding: boolean;\r\n        preventStuckBots: boolean;\r\n    };\r\n}\r\n\r\n@injectable()\r\nexport class HotZoneManager {\r\n    private hotZoneConfig: IHotZoneConfig;\r\n    private activeSpawns: Map<string, any[]> = new Map();\r\n    private spawnTimers: Map<string, NodeJS.Timeout> = new Map();\r\n\r\n    constructor(private configManager: ConfigManager) {\r\n        this.loadHotZoneConfig();\r\n    }\r\n\r\n    private loadHotZoneConfig(): void {\r\n        try {\r\n            // Load hot zone configuration\r\n            this.hotZoneConfig = this.configManager.loadHotZoneConfig();\r\n            console.log(\"[HotZoneManager] Hot zone configuration loaded successfully\");\r\n        } catch (error) {\r\n            console.error(\"[HotZoneManager] Error loading hot zone config:\", error);\r\n            this.hotZoneConfig = this.getDefaultHotZoneConfig();\r\n        }\r\n    }\r\n\r\n    private getDefaultHotZoneConfig(): IHotZoneConfig {\r\n        return {\r\n            enabled: true,\r\n            hotZones: {},\r\n            spawnDistribution: {\r\n                enabled: true,\r\n                minDistanceBetweenSpawns: 100,\r\n                maxSpawnsPerZone: 3,\r\n                zonePriority: { high: 1, medium: 2, low: 3 },\r\n                spawnTiming: {\r\n                    initialSpawnDelay: 30,\r\n                    waveSpacing: 300,\r\n                    randomization: 60\r\n                }\r\n            },\r\n            integration: {\r\n                waypointsMod: true,\r\n                bigBrainMod: true,\r\n                useExistingPathfinding: true,\r\n                preventStuckBots: true\r\n            }\r\n        };\r\n    }\r\n\r\n    public initializeHotZones(mapName: string): void {\r\n        if (!this.hotZoneConfig.enabled) {\r\n            console.log(\"[HotZoneManager] Hot zones disabled\");\r\n            return;\r\n        }\r\n\r\n        const mapHotZones = this.hotZoneConfig.hotZones[mapName];\r\n        if (!mapHotZones) {\r\n            console.log(`[HotZoneManager] No hot zones configured for map: ${mapName}`);\r\n            return;\r\n        }\r\n\r\n        console.log(`[HotZoneManager] Initializing hot zones for ${mapName}`);\r\n        \r\n        // Initialize spawn distribution\r\n        this.setupSpawnDistribution(mapName, mapHotZones);\r\n        \r\n        // Setup wave spawning\r\n        this.setupWaveSpawning(mapName, mapHotZones);\r\n    }\r\n\r\n    private setupSpawnDistribution(mapName: string, hotZones: Record<string, IHotZone>): void {\r\n        const { spawnDistribution } = this.hotZoneConfig;\r\n        \r\n        if (!spawnDistribution.enabled) return;\r\n\r\n        // Sort zones by priority\r\n        const sortedZones = Object.entries(hotZones)\r\n            .filter(([_, zone]) => zone.enabled)\r\n            .sort(([_, a], [__, b]) => \r\n                spawnDistribution.zonePriority[a.priority] - spawnDistribution.zonePriority[b.priority]\r\n            );\r\n\r\n        // Calculate spawn positions with minimum distance\r\n        const spawnPositions: Array<{zone: string, position: {x: number, y: number}}> = [];\r\n        \r\n        for (const [zoneName, zone] of sortedZones) {\r\n            const positions = this.calculateSpawnPositions(\r\n                zone,\r\n                spawnPositions,\r\n                spawnDistribution.minDistanceBetweenSpawns\r\n            );\r\n            \r\n            spawnPositions.push(...positions.map(pos => ({zone: zoneName, position: pos})));\r\n        }\r\n\r\n        // Store spawn positions for this map\r\n        this.activeSpawns.set(mapName, spawnPositions);\r\n        \r\n        console.log(`[HotZoneManager] Calculated ${spawnPositions.length} spawn positions for ${mapName}`);\r\n    }\r\n\r\n    private calculateSpawnPositions(\r\n        zone: IHotZone, \r\n        existingPositions: Array<{zone: string, position: {x: number, y: number}}>,\r\n        minDistance: number\r\n    ): Array<{x: number, y: number}> {\r\n        const positions: Array<{x: number, y: number}> = [];\r\n        const maxAttempts = 50;\r\n        let attempts = 0;\r\n\r\n        while (positions.length < zone.maxBots && attempts < maxAttempts) {\r\n            attempts++;\r\n            \r\n            // Generate random position within zone radius\r\n            const angle = Math.random() * 2 * Math.PI;\r\n            const radius = Math.random() * zone.coordinates.radius;\r\n            const x = zone.coordinates.x + Math.cos(angle) * radius;\r\n            const y = zone.coordinates.y + Math.sin(angle) * radius;\r\n\r\n            // Check distance from existing positions\r\n            const tooClose = existingPositions.some(existing => {\r\n                const distance = Math.sqrt(\r\n                    Math.pow(x - existing.position.x, 2) + \r\n                    Math.pow(y - existing.position.y, 2)\r\n                );\r\n                return distance < minDistance;\r\n            });\r\n\r\n            if (!tooClose) {\r\n                positions.push({x, y});\r\n            }\r\n        }\r\n\r\n        return positions;\r\n    }\r\n\r\n    private setupWaveSpawning(mapName: string, hotZones: Record<string, IHotZone>): void {\r\n        const { spawnTiming } = this.hotZoneConfig.spawnDistribution;\r\n        \r\n        // Initial spawn delay\r\n        const initialDelay = spawnTiming.initialSpawnDelay + \r\n            (Math.random() * spawnTiming.randomization);\r\n        \r\n        setTimeout(() => {\r\n            this.executeInitialSpawns(mapName, hotZones);\r\n        }, initialDelay * 1000);\r\n\r\n        // Setup wave spawning\r\n        this.setupWaveTimer(mapName, hotZones, spawnTiming.waveSpacing);\r\n    }\r\n\r\n    private executeInitialSpawns(mapName: string, hotZones: Record<string, IHotZone>): void {\r\n        console.log(`[HotZoneManager] Executing initial spawns for ${mapName}`);\r\n        \r\n        for (const [zoneName, zone] of Object.entries(hotZones)) {\r\n            if (!zone.enabled || Math.random() > zone.spawnChance) continue;\r\n            \r\n            const spawnPositions = this.activeSpawns.get(mapName) || [];\r\n            const zonePositions = spawnPositions.filter(sp => sp.zone === zoneName);\r\n            \r\n            // Spawn bots at calculated positions\r\n            this.spawnBotsInZone(zone, zonePositions, mapName);\r\n        }\r\n    }\r\n\r\n    private setupWaveTimer(mapName: string, hotZones: Record<string, IHotZone>, waveSpacing: number): void {\r\n        const timer = setInterval(() => {\r\n            this.executeWaveSpawn(mapName, hotZones);\r\n        }, waveSpacing * 1000);\r\n\r\n        this.spawnTimers.set(mapName, timer);\r\n    }\r\n\r\n    private executeWaveSpawn(mapName: string, hotZones: Record<string, IHotZone>): void {\r\n        console.log(`[HotZoneManager] Executing wave spawn for ${mapName}`);\r\n        \r\n        // Implement wave spawning logic here\r\n        // This will be called periodically to spawn additional bots\r\n    }\r\n\r\n    private spawnBotsInZone(zone: IHotZone, positions: Array<{zone: string, position: {x: number, y: number}}>, mapName: string): void {\r\n        // This method will integrate with SPT's bot spawning system\r\n        // For now, we'll log the intended spawns\r\n        console.log(`[HotZoneManager] Would spawn ${positions.length} ${zone.spawnTypes.join(', ')} bots in zone`);\r\n        \r\n        // TODO: Integrate with SPT bot spawning\r\n        // This will require access to SPT's bot spawning services\r\n    }\r\n\r\n    public cleanupMap(mapName: string): void {\r\n        // Clear spawn timers\r\n        const timer = this.spawnTimers.get(mapName);\r\n        if (timer) {\r\n            clearInterval(timer);\r\n            this.spawnTimers.delete(mapName);\r\n        }\r\n\r\n        // Clear active spawns\r\n        this.activeSpawns.delete(mapName);\r\n        \r\n        console.log(`[HotZoneManager] Cleaned up hot zones for ${mapName}`);\r\n    }\r\n\r\n    public getHotZoneInfo(mapName: string): any {\r\n        const mapHotZones = this.hotZoneConfig.hotZones[mapName];\r\n        if (!mapHotZones) return null;\r\n\r\n        return {\r\n            mapName,\r\n            totalZones: Object.keys(mapHotZones).length,\r\n            activeZones: Object.entries(mapHotZones)\r\n                .filter(([_, zone]) => zone.enabled)\r\n                .map(([name, zone]) => ({\r\n                    name,\r\n                    description: zone.description,\r\n                    priority: zone.priority,\r\n                    spawnTypes: zone.spawnTypes,\r\n                    maxBots: zone.maxBots\r\n                }))\r\n        };\r\n    }\r\n\r\n    public isHotZoneEnabled(mapName: string): boolean {\r\n        return this.hotZoneConfig.enabled && \r\n               !!this.hotZoneConfig.hotZones[mapName];\r\n    }\r\n}\r\n"],
  "mappings": "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",
  "names": []
}
